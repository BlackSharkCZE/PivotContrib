package com.gem.pivot.wtk.generated_form;

import com.gem.pivot.wtk.GemValidatorProvider;
import com.gem.pivot.wtk.TextCalendarMapping;
import com.gem.pivot.wtk.ValidationError;
import com.gem.pivot.wtk.annotations.DatePicker;
import com.gem.pivot.wtk.annotations.ListView;
import com.gem.pivot.wtk.annotations.Nullable;
import com.gem.pivot.wtk.support.ListButtonDataProvider;
import org.apache.commons.lang.StringUtils;
import org.apache.pivot.collections.Sequence;
import org.apache.pivot.util.CalendarDate;
import org.apache.pivot.wtk.*;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.MessageFormat;
import java.text.ParseException;
import java.util.*;
import java.util.Calendar;

/**
 * <strong>Created with IntelliJ IDEA</strong><br/>
 * User: Jiri Pejsa<br/>
 * Date: 16.6.15<br/>
 * Time: 9:16<br/>
 * <p>To change this template use File | Settings | File Templates.</p>
 */
public class AutoGeneratedForm extends Border {

	public static final String DATE_FORMAT = "dd.MM.yyyy";

	private Object someInst;
	private Map<String, Component> componentTree = new HashMap<>(10);
	private AutoGeneratedFormPerformListener autoGeneratedFormPerformListener;

	private String performButton;
	private String clearButton;

	private FieldType fieldType;


	private enum FieldType {
		LIST_VIEW, LIST_BUTTON
	}

	public AutoGeneratedForm() {
		super();
		init();
	}

	public AutoGeneratedForm(Component content) {
		super(content);
		init();
	}

	private void init() {
//		final MockListButtonDataProvider instance = BeanFactoryBuilder.getDefaultBeanFactory().createInstance(MockListButtonDataProvider.class);
		getStyles().put("padding", 0);
		getStyles().put("thickness", 0);

	}

	public void propertyChanged(String propertyName, Object value) {
		Object arg = null;

		if (componentTree.get(propertyName).getClass().isAssignableFrom(TextInput.class)) {
			if (value != null) {
				if (Calendar.class.isAssignableFrom(value.getClass())) {
					final TextInput textInput = (TextInput) componentTree.get(propertyName);
					textInput.setText(textInput.getTextBindMapping().toString(value));
				} else {
					((TextInput) componentTree.get(propertyName)).setText(value.toString());
				}
			} else {
				((TextInput) componentTree.get(propertyName)).setText("");
			}
		} else {
			if (componentTree.get(propertyName).getClass().isAssignableFrom(ListButton.class)) {
				ListButton listButton = ((ListButton) componentTree.get(propertyName));
				if (value == null) {
					listButton.setSelectedItem(arg);
				} else {
					listButton.setSelectedItem(value);
				}
			} else {
				if (componentTree.get(propertyName).getClass().isAssignableFrom(org.apache.pivot.wtk.ListView.class)) {
					org.apache.pivot.wtk.ListView lv = (org.apache.pivot.wtk.ListView) componentTree.get(propertyName);
					if (value == null) {
						lv.setSelectedItem(arg);
					} else {
						switch (lv.getSelectMode()) {
							case NONE:
							case SINGLE:
								lv.setSelectedItem(value);
								break;
							case MULTI:
								List l = (List) value;
								org.apache.pivot.collections.ArrayList a = new org.apache.pivot.collections.ArrayList();
								for (Object o : l) {
									a.add(o);
								}
								lv.setSelectedItems(a);
								break;
						}
					}
				}
			}
		}

	}

	public void propagateModelToView() {
		for (String key : componentTree.keySet()) {
			final Method getter;
			Object result = null;
			try {
				getter = someInst.getClass().getDeclaredMethod(buildGetterName(key), null);
				result = getter.invoke(someInst);
			} catch (Exception e) {
				e.printStackTrace();
			}
			propertyChanged(key, result);
		}
	}

	private void setCallBackObject() {
		try {
			final Field f = someInst.getClass().getSuperclass().getDeclaredField("dynCreatedObject");
			if (f.getType().isAssignableFrom(AutoGeneratedForm.class)) {
				f.setAccessible(true);
				f.set(someInst, this);
				f.setAccessible(false);
			}
		} catch (Exception e) {
			System.out.println("someInst can not register dynCreatedObject");
		}
	}

	private void initInstForm(final Object someInst) {
		BoxPane b = new BoxPane(Orientation.VERTICAL);
		System.out.println("*********** INIT BY OBJECT INSTANCE ***************");
		final Field[] declaredFields = someInst.getClass().getDeclaredFields();
		for (Field df : declaredFields) {
			String label = df.getName();
			Class<? extends ListButtonDataProvider> listButtonP = null;
			DatePicker datePicker = null;
			final Annotation[] declaredAnnotations = df.getDeclaredAnnotations();

			for (Annotation an : declaredAnnotations) {
				if (an.annotationType().isAssignableFrom(com.gem.pivot.wtk.annotations.Label.class)) {
					label = ((com.gem.pivot.wtk.annotations.Label) an).value();
					continue;
				}
				if (an.annotationType().isAssignableFrom(com.gem.pivot.wtk.annotations.ListButton.class)) {
					listButtonP = ((com.gem.pivot.wtk.annotations.ListButton) an).dataProvider();
					fieldType = FieldType.LIST_BUTTON;
					continue;
				}
				if (an.annotationType().isAssignableFrom(ListView.class)) {
					listButtonP = ((ListView) an).dataProvider();
					fieldType = FieldType.LIST_VIEW;
					continue;
				}
				if (an.annotationType().isAssignableFrom(DatePicker.class)) {
					datePicker = (DatePicker) an;
				}
			}

			if (listButtonP != null) {

				switch (fieldType) {
					case LIST_VIEW:
						b.add(buildListViewByString(someInst, df, label, listButtonP));
						break;
					case LIST_BUTTON:
						b.add(buildListButtonByString(someInst, df, label, listButtonP));
						break;
					default:
						break;
				}
			}

			if (datePicker != null && df.getType().isAssignableFrom(Calendar.class)) {
				b.add(buildCalendarPicker(someInst, df, label, datePicker));
				continue;
			}

			if (df.getType().isAssignableFrom(String.class)) {
				b.add(buildComponentByString(someInst, df, label));
			} else {
				if (df.getType().isAssignableFrom(Integer.class)) {
					b.add(buildComponentByString(someInst, df, label));
				} else {
					if (df.getType().isAssignableFrom(Calendar.class)) {
						b.add(buildCalendarPicker(someInst, df, label, datePicker));
					}
				}
			}


			/*if (Modifier.isPrivate(df.getModifiers())) {
				System.out.print("Private field: ");
			} else {
				System.out.print("Public field: ");
			}
			System.out.println(df.getName() + ": " + df.getType().getSimpleName() + ": " + df.getGenericType() + ": " + df.getType().toString());*/
		}

		b.add(addButtons());
		setContent(b);
		repaint(true);
	}

	private List<ValidationError> validateAndBind() throws NoSuchFieldException {
		List<ValidationError> error = new ArrayList<>(5);

		for (String key : componentTree.keySet()) {
			final String[] parts = key.split(":");
			final String getterName = buildGetterName(key);
			if (getterName != null) {
				try {
					final Field field = someInst.getClass().getDeclaredField(key);
					final Method getter = someInst.getClass().getDeclaredMethod(getterName, null);
					final Class<?> returnType = getter.getReturnType();
					final Method setter = someInst.getClass().getDeclaredMethod(buildSetterName(key), returnType);

					// setter is present, settings value is possible
					Component c = componentTree.get(key);

					final com.gem.pivot.wtk.annotations.ListButton listButton = field.getAnnotation(com.gem.pivot.wtk.annotations.ListButton.class);
					final com.gem.pivot.wtk.annotations.ListView listView = field.getAnnotation(com.gem.pivot.wtk.annotations.ListView.class);

					if (listButton != null) {
						ListButton lb = (ListButton) c;
						validateAndBindListButtonObject(lb, setter, returnType, error, key);
						continue;
					}

					if (listView != null) {
						org.apache.pivot.wtk.ListView lv = (org.apache.pivot.wtk.ListView) c;
						validateAndBindListViewObject(lv, setter, returnType, error, key);
						continue;
					}

					if (String.class == returnType) {
						validateAndBindString(((TextInput) c), setter, returnType, error, key);
					} else {
						if (Calendar.class.isAssignableFrom(returnType)) {

							if (c.getClass().isAssignableFrom(TextInput.class)) {
								validateAndBindCalendar(((TextInput) c), setter, returnType, error, key);
								continue;
							}

							if (c.getClass().isAssignableFrom(CalendarButton.class)) {
								validateAndBindCalendarButton(((CalendarButton) c), setter, returnType, error, key);
							}

						} else {
							if (Integer.class.isAssignableFrom(returnType)) {
								validateAndBindInteger(((TextInput) c), setter, returnType, error, key);
							}
						}
					}


				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				System.out.println("Can not build getter name for field " + key);
			}
		}
		return error;
	}

	private Component addButtons() {
		BoxPane bp = new BoxPane(Orientation.HORIZONTAL);
		if (performButton != null) {
			PushButton butOk = new PushButton();
			butOk.setButtonData(performButton);
			butOk.setAction(new Action() {
				@Override
				public void perform(Component source) {
					final List<ValidationError> validationErrors;
					try {
						validationErrors = validateAndBind();
						if (validationErrors.isEmpty()) {
							autoGeneratedFormPerformListener.perform(someInst);
						} else {
							autoGeneratedFormPerformListener.validationError(someInst, validationErrors);
						}
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
			});
			bp.add(butOk);
		}

		if (clearButton != null) {
			PushButton butClear = new PushButton();
			butClear.setButtonData(clearButton);
			butClear.setAction(new Action() {
				@Override
				public void perform(Component source) {
					for (String key : componentTree.keySet()) {
						propertyChanged(key, null);
					}
				}
			});
			bp.add(butClear);
		}

		return bp;
	}

	private void validateAndBindString(final TextInput value,
																		 final Method setter,
																		 final Class<?> fieldType,
																		 final List<ValidationError> error,
																		 final String field) throws InvocationTargetException, IllegalAccessException {
		if (value.getValidator().isValid(value.getText())) {
			if (StringUtils.isEmpty(value.getText())) {
				Object arg = null;
				setter.invoke(someInst, arg);
			} else {
				setter.invoke(someInst, value.getText());
			}
		}
	}

	private void validateAndBindInteger(final TextInput textInput,
																			final Method setter,
																			final Class<?> fieldType,
																			List<ValidationError> error,
																			String field) throws InvocationTargetException, IllegalAccessException {
		try {
			if (textInput.getValidator().isValid(textInput.getText())) {
				if (StringUtils.isEmpty(textInput.getText())) {
					Object arg = null;
					setter.invoke(someInst, arg);
				} else {
					Integer val = Integer.parseInt(textInput.getText());
					setter.invoke(someInst, val);
				}
			} else {
				error.add(new ValidationError(field, "Value \"" + textInput.getText() + "\" is not valid Integer or is out of range."));
			}

		} catch (NumberFormatException e) {
			e.printStackTrace();
			error.add(new ValidationError(field, MessageFormat.format("Can not convert \"{0}\" to valid Integer.", textInput.getText())));
		}
	}

	private void validateAndBindListButtonObject(final ListButton listButton,
																							 final Method setter,
																							 final Class<?> returnType,
																							 final List<ValidationError> error,
																							 final String fieldName) throws InvocationTargetException, IllegalAccessException, NoSuchFieldException {
		final Nullable annotation = someInst.getClass().getDeclaredField(fieldName).getAnnotation(Nullable.class);
		if (annotation != null) {
			boolean nullable = ((Nullable) annotation).value();
			if (!nullable && listButton.getSelectedItem() == null) {
				error.add(new ValidationError(fieldName, MessageFormat.format("Filed \"{0}\" is Nullable(false).", fieldName)));
			} else {
				setter.invoke(someInst, listButton.getSelectedItem());
			}
		}
	}

	private void validateAndBindListViewObject(final org.apache.pivot.wtk.ListView listView,
																						 final Method setter,
																						 final Class<?> returnType,
																						 final List<ValidationError> error,
																						 final String fieldName) throws InvocationTargetException, IllegalAccessException, NoSuchFieldException {
		final Nullable annotation = someInst.getClass().getDeclaredField(fieldName).getAnnotation(Nullable.class);
		if (annotation != null) {
			boolean nullable = annotation.value();
			if (!nullable && listView.getSelectedItem() == null) {
				error.add(new ValidationError(fieldName, MessageFormat.format("Filed \"{0}\" is Nullable(false).", fieldName)));
				return;
			}
		}

		if (returnType.isAssignableFrom(List.class)) {
			final Sequence<?> selectedItems = listView.getSelectedItems();
			List l = new ArrayList(selectedItems.getLength());
			for (int a = 0; a < selectedItems.getLength(); a++) {
				l.add(selectedItems.get(a));
			}
			setter.invoke(someInst, l);
		} else {
			setter.invoke(someInst, listView.getSelectedItem());
		}


	}

	private void validateAndBindCalendarButton(final CalendarButton calendarButton,
																						 final Method setter,
																						 final Class<?> fieldType,
																						 List<ValidationError> error,
																						 String field) throws InvocationTargetException, IllegalAccessException {
		if (calendarButton.getSelectedDate() == null) {
			Object arg = null;
			setter.invoke(someInst, arg);
		} else {
			final Calendar calendar = pivotCalendarToJavaCalendar(calendarButton.getSelectedDate());
			System.out.println(calendar.getTime());
			setter.invoke(someInst, calendar);
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}

	}

	private void validateAndBindCalendar(final TextInput textInput,
																			 final Method setter,
																			 final Class<?> fieldType,
																			 List<ValidationError> error,
																			 String field) throws InvocationTargetException, IllegalAccessException {
		try {
			if (textInput.getValidator().isValid(textInput.getText())) {
				if (StringUtils.isEmpty(textInput.getText())) {
					Object arg = null;
					setter.invoke(someInst, arg);
				} else {
					setter.invoke(someInst, textInput.getTextBindMapping().valueOf(textInput.getText()));
				}
			} else {
				throw new ParseException("Invalid data for parse date. Input data: " + textInput.getText(), 0);
			}
		} catch (ParseException e) {
			e.printStackTrace();
			error.add(new ValidationError(field, MessageFormat.format("Can not convert \"{0}\" to valid Date format with pattern {1} Integer.", textInput, DATE_FORMAT)));
		}
	}

	private Component buildListViewByString(Object object, Field field, String label, Class<? extends ListButtonDataProvider> dp) {
		BoxPane bp = new BoxPane(Orientation.HORIZONTAL);
		Label l = new Label(label + ": ");
		org.apache.pivot.wtk.ListView lb = new org.apache.pivot.wtk.ListView();

		if (field.getType().isAssignableFrom(List.class)) {
			lb.setSelectMode(org.apache.pivot.wtk.ListView.SelectMode.MULTI);
		} else {
			lb.setSelectMode(org.apache.pivot.wtk.ListView.SelectMode.SINGLE);
		}

		componentTree.put(field.getName(), lb);
		final ListButtonDataProvider listButtonDataProvider;
		try {
			listButtonDataProvider = dp.newInstance();
			final List data = listButtonDataProvider.getData();

			org.apache.pivot.collections.ArrayList<Object> res = new org.apache.pivot.collections.ArrayList<>();
			for (Object o : data) {
				res.add(o);
			}

			lb.setListData(res);
		} catch (Exception e) {
			e.printStackTrace();
		}

		bp.add(l);
		bp.add(lb);
		return bp;
	}

	private Component buildListButtonByString(Object object, Field field, String label, Class<? extends ListButtonDataProvider> dp) {
		BoxPane bp = new BoxPane(Orientation.HORIZONTAL);
		Label l = new Label(label + ": ");
		ListButton lb = new ListButton();
		componentTree.put(field.getName(), lb);
		final ListButtonDataProvider listButtonDataProvider;
		try {
			listButtonDataProvider = dp.newInstance();
			final List data = listButtonDataProvider.getData();

			org.apache.pivot.collections.ArrayList<Object> res = new org.apache.pivot.collections.ArrayList<>();
			for (Object o : data) {
				res.add(o);
			}
			lb.setListData(res);
		} catch (Exception e) {
			e.printStackTrace();
		}

		bp.add(l);
		bp.add(lb);
		return bp;
	}


	private Component buildCalendarPicker(Object object, Field field, String label, DatePicker datePicker) {

		if (datePicker.textInput()) {
			return buildTextCalendarPicker(object, field, label, datePicker);
		} else {
			return buildComponentCalendarPicker(object, field, label, datePicker);
		}


	}

	private Component buildComponentCalendarPicker(Object object, Field field, String label, DatePicker datePicker) {
		BoxPane bp = new BoxPane(Orientation.HORIZONTAL);
		CalendarButton ti = new CalendarButton();
		//todo CalendarButtonDateRenderer is GEM renderer
		//ti.setDataRenderer(new CalendarButtonDateRenderer());
		Label l = new Label(label + ": ");
		componentTree.put(field.getName(), ti);

		try {
			final Method getter = object.getClass().getDeclaredMethod(buildGetterName(field.getName()));
			if (getter.getReturnType().isAssignableFrom(Calendar.class)) {
				final Calendar result = (Calendar) getter.invoke(object);
				if (result != null) {
					ti.setSelectedDate(javaDateToPivotCalendar(result));
				}
			}
		} catch (NoSuchMethodException e) {
			e.printStackTrace();
		} catch (InvocationTargetException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		}

		bp.add(l);
		bp.add(ti);
		return bp;
	}

	private Component buildTextCalendarPicker(Object object, Field field, String label, DatePicker datePicker) {
		BoxPane bp = new BoxPane(Orientation.HORIZONTAL);
		TextInput ti = new TextInput();
		ti.setTextBindMapping(new TextCalendarMapping(datePicker.pattern()));
		ti.setValidator(GemValidatorProvider.getValidatorForField(object, field));
		Label l = new Label(label + ": ");
		componentTree.put(field.getName(), ti);

		try {
			final Method getter = object.getClass().getDeclaredMethod(buildGetterName(field.getName()));
			if (getter.getReturnType().isAssignableFrom(Calendar.class)) {
				final Calendar result = (Calendar) getter.invoke(object);
				if (result != null) {
					ti.setText(ti.getTextBindMapping().toString(result));
				}
			}
		} catch (NoSuchMethodException e) {
			e.printStackTrace();
		} catch (InvocationTargetException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		}

		bp.add(l);
		bp.add(ti);
		return bp;
	}

	private CalendarDate javaDateToPivotCalendar(Calendar result) {
		return new CalendarDate(result.get(Calendar.YEAR), result.get(Calendar.MONTH), result.get(Calendar.DAY_OF_MONTH));
	}

	private Calendar pivotCalendarToJavaCalendar(CalendarDate result) {
		Calendar c = Calendar.getInstance();
//		System.out.println(c.getTime());

		c.set(Calendar.YEAR, result.year);
		c.set(Calendar.MONTH, result.month);
		c.set(Calendar.DAY_OF_MONTH, result.day + 1);
		c.set(Calendar.HOUR, 0);
		c.set(Calendar.MINUTE, 0);
		c.set(Calendar.SECOND, 0);
		System.out.println(c.getTime());

		return c;
	}

	private Component buildComponentByString(Object o, Field field, String label) {
		BoxPane bp = new BoxPane(Orientation.HORIZONTAL);
		TextInput ti = new TextInput();
		ti.setValidator(GemValidatorProvider.getValidatorForField(o, field));
		Label l = new Label(label + ": ");
		componentTree.put(field.getName(), ti);

		try {
			field.setAccessible(true);
			if (field.get(o) != null) {
				ti.setText(field.get(o).toString());
			}
		} catch (IllegalAccessException e) {

		}
		bp.add(l);
		bp.add(ti);
		return bp;
	}

	private String buildSetterName(final String fieldName) {
		if (fieldName != null && fieldName.length() >= 1) {
			return "set" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
		} else {
			return null;
		}
	}

	private String buildGetterName(final String fieldName) {
		if (fieldName != null && fieldName.length() >= 1) {
			return "get" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
		} else {
			return null;
		}
	}

	public Object getSomeInst() {
		return someInst;
	}

	public void setSomeInst(Object someInst) {
		this.someInst = someInst;
		setCallBackObject();
		initInstForm(someInst);
	}

	public AutoGeneratedFormPerformListener getAutoGeneratedFormPerformListener() {
		return autoGeneratedFormPerformListener;
	}

	public void setAutoGeneratedFormPerformListener(AutoGeneratedFormPerformListener autoGeneratedFormPerformListener) {
		this.autoGeneratedFormPerformListener = autoGeneratedFormPerformListener;
	}

	public String getPerformButton() {
		return performButton;
	}

	public void setPerformButton(String performButton) {
		this.performButton = performButton;
	}

	public String getClearButton() {
		return clearButton;
	}

	public void setClearButton(String clearButton) {
		this.clearButton = clearButton;
	}
}
